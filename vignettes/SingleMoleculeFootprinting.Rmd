---
title: "SingleMoleculeFootprinting"
output: 
  html_document:
    toc: true
    toc_float: true
vignette: >
  %\VignetteIndexEntry{SingleMoleculeFootprinting}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)

# knit in the right folder:
# rmarkdown::render("/g/krebs/barzaghi/Rscripts/R_package/SingleMoleculeFootprinting/vignettes/SingleMoleculeFootprinting.Rmd", output_dir = "/g/krebs/barzaghi/Rscripts/R_package/SingleMoleculeFootprinting/vignettes", output_format = "html_document")
```

### Introduction
*SingleMoleculeFootprinting* is a simple package with convenience function to analyze Single Molecule Footprinting (SMF) data. As of now, we provide analysis tools starting from aligned data. To that end we recommend the user to perform their genomic alignement using the [qAlign](https://www.rdocumentation.org/packages/QuasR/versions/1.12.0/topics/qAlign) function from QuasR as exemplified in **Our Paper**.

### Installation
```{r, eval=F}
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("SingleMoleculeFootprinting")
```

### Loading
```{r setup, message=F, eval=F}
library(SingleMoleculeFootprinting)
```

### Define arguments
*SingleMoleculeFootprinting* inherits *QuasR*'s philosophy of working with pointer files. Briefly, a pointer file consists of a tab-delimited file with two or three fields, depending on whether the input files are raw paired-end, raw single-end or aligned. For more details, please check the [qAlign documentation](https://www.rdocumentation.org/packages/QuasR/versions/1.12.0/topics/qAlign).
```{r, eval=F}
Qinput = system.file("extdata", "QuasR_input_pairs.txt", package = "SingleMoleculeFootprinting", mustWork = T)
out_path=paste("/g/krebs/barzaghi/Rscripts/R_package/VignetteOutDir/")
CoverageThreshold = 19

Region_of_interest = GRanges(seqnames = "chr6", ranges = IRanges(start = 88106000, end = 88106500), strand = "+")
TFBSs = GenomicRanges::GRanges("chr6", IRanges(c(88106216, 88106253), c(88106226, 88106263)), strand = "-")
elementMetadata(TFBSs)$name = c("NRF1", "NRF1")
names(TFBSs) = c(paste0("TFBS_", c(4305215, 4305216)))
TFBSs = GenomicRanges::GRangesList(TFBS_cluster_13723 = TFBSs)
```

Create QuasR project: because we provide pre-aligned data, QuasR will not attempt to re-align.
```{r, eval=F}
SMFproj=QuasR::qAlign(sampleFile=Qinput,
                genome="BSgenome.Mmusculus.UCSC.mm10",
                projectName = "CTCF_amplicon",
                paired="fr",
                aligner = "Rbowtie",
                bisulfite="undir")
SMFaln=QuasR::alignments(SMFproj)[[1]]
SMFproj@aligner = "Rbowtie"
```

### QCs
```{r, eval=F}
# 1. If SMF was performed on an large genome (e.g Mouse) you probably did some bait capture: here we check how efficient that was
BaitRegions = import("/g/krebs/barzaghi/DB/misc/mm10_baits.bed.gz", format="bed")
BaitCaptureEfficiency = BaitCapture(sampleSheet = Qinput, genome = BSgenome.Mmusculus.UCSC.mm10, baits = BaitRegions)
BaitCaptureEfficiency

# In this case the capture efficiency equals to 1 because the example data was purpossefully subsetted for an interesting region. Under normal condition, one expects this value to be lower than 1: for the mouse genome for example we observe values around 0.7.

# 2. Coversion rate: this asks how much out-of-context methylation has occurred during the experiment. Beware, this is a much slower computation than the above. Expected value ~95
ConversionRateEstimate = ConversionRate(sampleSheet = Qinput, genome = BSgenome.Mmusculus.UCSC.mm10, chr = 6)
ConversionRateEstimate # 92.4

# Intersample correlation of methylation fractions: 

```


### Methylation calling - amplicon example 
```{r, eval=F}
# Average methylation for permissive contexts (use all for TKO exp.)
CCM = CallContextMethylation(QuasRprj = SMFproj, range = Region_of_interest, coverage = CoverageThreshold, genome = Mmusculus)
CSM = getGCMatrix(QuasRprj = SMFproj, range = Region_of_interest, sample = SMFaln$SampleName[1], genome = Mmusculus)
mergedCSM = mergeGC_CGmat(CSM) # if TKO
mergedCCM = sort(append(CCM$CG, CCM$GC))

# Sort reads
# Add sample name to range (same as for qAlign prj)
regDF = cbind(as.data.frame(Region_of_interest)[,1:3], sample = SMFaln$SampleName)

sortedReads = SortSingleMolecules(regDF = regDF, sampleSheet = Qinput, target_range = TFBSs)

# clean up
GCGs = mergedCCM[which(!is.na(mergedCCM$MethylationFraction) & mergedCCM$type == "GCG")]
reducedGCGs = GenomicRanges::reduce(GCGs)
elementMetadata(reducedGCGs)$MethylationFraction = as.matrix(unlist(lapply(seq(1, length(GCGs), 2), function(n){mean(c(GCGs$MethylationFraction[n], GCGs$MethylationFraction[n+1]))})))
elementMetadata(reducedGCGs)$type = "GCG"
cleanedCCM = sort(c(mergedCCM[which(!is.na(mergedCCM$MethylationFraction) & mergedCCM$type != "GCG")], reducedGCGs))

PlotSingleTF(AvgMeth = cleanedCCM, SingleMoleculeMeth = mergedCSM, sample = SMFaln$SampleName, range = Region_of_interest, TFBSs = TFBSs, SortedReads = sortedReads, OutPath = paste0(out_path, "NRF1pair_singleSite.pdf"))
```


--------
********

### Genome-wide example
Given the example data only cover one genomic region, we are going to restrict the following chunk to the interested chromosome only
This process can be quite lengthy and computationally demanding, it is advisable to run it on the cluster.
```{r, eval=F}
# Partition a genome by chromosome ("natural partitioning")
musmus_length=seqlengths(Mmusculus)[1:21] # change [1] to [1:21] to expand the analysis to the whole genome
tiles <- tileGenome(musmus_length, tilewidth=max(musmus_length),cut.last.tile.in.chrom=TRUE)

# Call the methylation genome wide for all Cs, loop/chromosome
# Cluster object for parallel processing of multiple samples
cluObj=makeCluster(length(SMFaln$SampleName))
lapply(1:length(tiles),function(i){

  print(i)
  
	meth_gr <- QuasR::qMeth(SMFproj, mode="allC", tiles[i], clObj=cluObj)
	contextMet=CallContextMethylation(meth_gr, cO, Mmusculus)
	saveRDS(contextMet, paste0(out_path,'/Context_met_call_',SMFproj@projectName,'_',as.character(seqnames( tiles[i])),'_Co',as.character(cO),'.rds',sep=''))

	})

# Filter away Cytosines with low coverage in all samples and combine chromosome-specific objects
AllCf=mclapply(1:length(tiles),function(i){

	contextMet=readRDS(paste(out_path,'/Context_met_call_',SMFproj@projectName,'_',as.character(seqnames( tiles[i])),'_Co',as.character(cO),'.rds',sep=''))
	CG=contextMet[[1]]
	GC=contextMet[[2]]
	AllC=c(CG,GC)
	met=elementMetadata(AllC)
	met2=met[,1:(ncol(met)-1)]
	cov.inx=!rowSums(is.na(met2))==ncol(met2)
	AllCf=AllC[cov.inx]
	AllCf

}, mc.cores=length(tiles))

AllC=unlist(GRangesList(AllCf))
AllC=sort(AllC)

# save final object
saveRDS(AllC, paste0(out_path,'/Context_methylation_call_',SMFproj@projectName,'.rds'))

# remove chromosome-wise temporary files
lapply(1:length(tiles), function(i){
  file.remove(paste0(out_path,'/Context_met_call_',SMFproj@projectName,'_',as.character(seqnames( tiles[i])),'_Co',as.character(cO),'.rds',sep=''))
})
```


* Bulleted list
* Item 2
    * Nested bullets need a 4-space indent.
    * Item 2b












