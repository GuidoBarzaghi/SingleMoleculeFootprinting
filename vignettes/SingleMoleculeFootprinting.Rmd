---
title: "SingleMoleculeFootprinting"
output: 
  html_document:
    toc: true
    toc_float: true
    toc_depth: 4
    highlight: tango
vignette: >
  %\VignetteIndexEntry{SingleMoleculeFootprinting}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, echo = FALSE, message=F}
knitr::opts_chunk$set(
  collapse = TRUE,
  # comment = "#>", 
  tidy = F, 
  cache = T, 
  results = 'markup'
)

# knit in the right folder:
# rmarkdown::render("/g/krebs/barzaghi/Rscripts/R_package/SingleMoleculeFootprinting/vignettes/SingleMoleculeFootprinting.Rmd", output_dir = "/g/krebs/barzaghi/Rscripts/R_package/SingleMoleculeFootprinting/vignettes", output_format = "html_document")
```

## Graphical things to fix

* Display messages outside code chunks
* 

## Introduction
*SingleMoleculeFootprinting* is a simple package with convenience function to analyze Single Molecule Footprinting (SMF) data. As of now, we provide analysis tools starting from aligned data. To that end we recommend the user to perform their genomic alignement using the [qAlign](https://www.rdocumentation.org/packages/QuasR/versions/1.12.0/topics/qAlign) function from QuasR as exemplified in **Our Paper** and the chuck below.
```{r, eval=F}
cl = makeCluster(40)
prj = qAlign(sampleFile = Qinput,
              genome = "BSgenome.Mmusculus.UCSC.mm10",
              aligner = "Rbowtie",
              projectName = "", 
              paired = "fr",
              bisulfite = "undir", 
              alignmentParameter = "-e 70 -X 1000 -k 2 --best -strata",
              alignmentsDir = "", 
              cacheDir = "",
              clObj = cl)
```


## Installation {.tabset}
### Developer installation
For develop installation, visit our [repository](https://github.com/Krebslabrep/SingleMoleculeFootprinting) on GitHub and copy link for cloning.
```{r, eval=F}
INSTALLATION_LOCATION = ""
REPO_LINK = ""

system(paste0("cd ", INSTALLATION_LOCATION))
system(paste0("git clone ", REPO_LINK))
devtools::install(paste0(INSTALLATION_LOCATION, "/SingleMoleculeFootprinting/"))
```

### Bioconductor installation
For Bioconductor installation, visit the Bioconductor webpage for SingleMoleculeFootprinting (NOT YET AVAILABLE)
```{r, eval=F}
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("SingleMoleculeFootprinting")
```

## Loading
```{r setup, message=F, eval=T}
library(BSgenome.Mmusculus.UCSC.mm10)
# library(SingleMoleculeFootprinting)
devtools::load_all()
```

## Define arguments
*SingleMoleculeFootprinting* inherits *QuasR*'s philosophy of working with pointer files. Briefly, a pointer file consists of a tab-delimited file with two or three fields, depending on whether the input files are raw paired-end, raw single-end or aligned. For more details, please check the qAlign [documentation](https://www.rdocumentation.org/packages/QuasR/versions/1.12.0/topics/qAlign). Here we show how our pointer file looks like.
```{r, eval=T}
Qinput = system.file("extdata", "QuasR_input_pairs.txt", package = "SingleMoleculeFootprinting", mustWork = T)
suppressMessages(read_delim(Qinput, delim = "\t"))
# sample = read_tsv(Qinput)[[2]]
# 
# out_path=paste("/g/krebs/barzaghi/Rscripts/R_package/VignetteOutDir/")
# CoverageThreshold = 19
# 
# Region_of_interest = GRanges(seqnames = "chr6", ranges = IRanges(start = 88106000, end = 88106500), strand = "*")
# TFBSs = GenomicRanges::GRanges("chr6", IRanges(c(88106216, 88106253), c(88106226, 88106263)), strand = "-")
# elementMetadata(TFBSs)$name = c("NRF1", "NRF1")
# names(TFBSs) = c(paste0("TFBS_", c(4305215, 4305216)))
# TFBSs = GenomicRanges::GRangesList(TFBS_cluster_13723 = TFBSs)
```

## Library QCs
Before investing in a deep sequencing run for a SMF experiment, it is advisable to first do a shallow sequencing run (e.g. MiSeq) and to perform quality controls on the sequencing libraries.\

### Bait capture efficiency
If SMF was performed on an large genome (e.g Mouse) you probably did some bait capture: here we check how efficient that process was by essentially computing the ratio of genomic alignments inside bait regions over the total ones.
```{r, eval=T}
# BaitRegions = import("/g/krebs/barzaghi/DB/misc/mm10_baits.bed.gz", format="bed")
# BaitCaptureEfficiency = BaitCapture(sampleSheet = Qinput, genome = BSgenome.Mmusculus.UCSC.mm10, baits = BaitRegions)
BaitCaptureEfficiency = 1
```
In this case the capture efficiency equals to `r toString(BaitCaptureEfficiency)` because the example data was purpossefully subsetted for an interesting region which falls entirely within baits. Under normal condition, one expects this value to be lower than 1: for the mouse genome for example we observe values around 0.7.

### Conversion rate precision
Here we ask how much of the observed Cytosine methylation falls in the expected contexts (CpG or GpC). Beware, this is a much slower computation than the above.
```{r, eval=T}
# ConversionRateEstimate = ConversionRate(sampleSheet = Qinput, genome = BSgenome.Mmusculus.UCSC.mm10, chr = 6)
ConversionRateEstimate = 92.5
```
For this sample, the observed conversion rate is `r toString(ConversionRateEstimate)`. This value happens to be slightly below the expected value of ~95

### Intersample correlation
Compare methylation fractions across samples. This gives a broad overview of whether the methylation pattern of a cell type or condition reflects what previously observed
```{r, eval=F}

```

## Analysis of single site (Amplicon data)
### Methylation extraction
Methylation values at the single molecule level can be extracted for the region of interest from aligned data using the *CallContextMethylation* function. \
Under the hood, the function performs the following operations: \

* Identification of the methylation status for the Cytosines in the genomic context relevant for the experiment (Single enzyme, double enzyme, etc.). The type of the experiment in inferred based on which user-provided substring is found in the SampleName field of the QuasR pointer file: \
```{r, echo = F}
knitr::kable(data.frame(ExperimentType = c("Single enzyme SMF", "Double enzyme SMF", "No enzyme (endogenous mCpG only)"), 
                        substring = c("\\_NO_", "\\_DE_", "\\_SS_"), 
                        RelevanContext = c("DGCHN & NWCGW", "GCH + HCG", "CG"), 
                        Notes = c("Methylation info is reported separately for each context", "Methylation information is aggregated across the contexts", "-")))
```

* Filtering reads based on conversion rate
* Strand collapsing
* Filtering Cytosines for coverage
```{r, eval=T}
MySample = suppressMessages(read_tsv(Qinput)[[2]])
Region_of_interest = GRanges(seqnames = "chr6", ranges = IRanges(start = 88106000, end = 88106500), strand = "*")

Methylation = CallContextMethylation(sampleSheet = Qinput, 
                                     sample = MySample, 
                                     genome = BSgenome.Mmusculus.UCSC.mm10, 
                                     range = Region_of_interest, 
                                     coverage = 20, 
                                     ConvRate.thr = 0.2)
Methylation[[1]]
Methylation[[2]][1:10, 1:10]
```

### Plotting single sites
```{r, eval=T}
TFBSs = GenomicRanges::GRanges("chr6", IRanges(c(88106216, 88106253), c(88106226, 88106263)), strand = "-")
elementMetadata(TFBSs)$name = c("NRF1", "NRF1")
names(TFBSs) = c(paste0("TFBS_", c(4305215, 4305216)))

PlotAvgSMF(MethGR = Methylation[[1]], range = Region_of_interest, TFBSs = TFBSs)
PlotSM(MethSM = Methylation[[2]], range = Region_of_interest)
```

Optionally, reads can be classified by hierarchical clustering
```{r, eval=T}
PlotSM(MethSM = Methylation[[2]], range = Region_of_interest, SortedReads = "HC")
```

Ultimately though, we want to classify reads based on the patterns of TF occupancy.
```{r, eval=T}
# note for myself: in the original code there was a remove.duplicates parameter at this stage. Nowhere else. If needed, this should be implemented in CallContextMethylation such that also the Avg methylation is computed after this removal. Does it makes sense to have it? Because for GW experiments, duplicates are removed during pre-processing and for amplicon exp duplicates shouldn't be removed?

SortedReads_singleTF = SortReadsBySingleTF(MethSM = Methylation[[2]], TFBS = TFBSs[2]) # TFBSs[2] would have an empty bin
length(SortedReads_singleTF)
names(SortedReads_singleTF)
lapply(SortedReads_singleTF, length)

PlotSM(MethSM = Methylation[[2]], range = Region_of_interest, SortedReads = SortedReads_singleTF) # not tested yet
```

```{r}
SortedReads_TFCluster = SortReadsByTFCluster(MethSM = Methylation[[2]], TFBSs = TFBSs)
length(SortedReads_TFCluster)
names(SortedReads_TFCluster)
lapply(SortedReads_TFCluster, length)

PlotSM(MethSM = Methylation[[2]], range = Region_of_interest, SortedReads = SortedReads_TFCluster) # WTF I'm getting almost the same plot
```

## Analysis of single site (Genome-wide data)
```{r}

```


--------
********

## Genome-wide analysis
Given the example data only cover one genomic region, we are going to restrict the following chunk to the interested chromosome only
This process can be quite lengthy and computationally demanding, it is advisable to run it on a cluster.
```{r, eval=F}
# Partition a genome by chromosome ("natural partitioning")
musmus_length=seqlengths(Mmusculus)[1:21] # change [1] to [1:21] to expand the analysis to the whole genome
tiles <- tileGenome(musmus_length, tilewidth=max(musmus_length),cut.last.tile.in.chrom=TRUE)

# Call the methylation genome wide for all Cs, loop/chromosome
# Cluster object for parallel processing of multiple samples
cluObj=makeCluster(length(SMFaln$SampleName))
lapply(1:length(tiles),function(i){

  print(i)
  
	meth_gr <- QuasR::qMeth(SMFproj, mode="allC", tiles[i], clObj=cluObj)
	contextMet=CallContextMethylation(meth_gr, cO, Mmusculus)
	saveRDS(contextMet, paste0(out_path,'/Context_met_call_',SMFproj@projectName,'_',as.character(seqnames( tiles[i])),'_Co',as.character(cO),'.rds',sep=''))

	})

# Filter away Cytosines with low coverage in all samples and combine chromosome-specific objects
AllCf=mclapply(1:length(tiles),function(i){

	contextMet=readRDS(paste(out_path,'/Context_met_call_',SMFproj@projectName,'_',as.character(seqnames( tiles[i])),'_Co',as.character(cO),'.rds',sep=''))
	CG=contextMet[[1]]
	GC=contextMet[[2]]
	AllC=c(CG,GC)
	met=elementMetadata(AllC)
	met2=met[,1:(ncol(met)-1)]
	cov.inx=!rowSums(is.na(met2))==ncol(met2)
	AllCf=AllC[cov.inx]
	AllCf

}, mc.cores=length(tiles))

AllC=unlist(GRangesList(AllCf))
AllC=sort(AllC)

# save final object
saveRDS(AllC, paste0(out_path,'/Context_methylation_call_',SMFproj@projectName,'.rds'))

# remove chromosome-wise temporary files
lapply(1:length(tiles), function(i){
  file.remove(paste0(out_path,'/Context_met_call_',SMFproj@projectName,'_',as.character(seqnames( tiles[i])),'_Co',as.character(cO),'.rds',sep=''))
})
```


